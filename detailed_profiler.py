"""
ÏÉÅÏÑ∏Ìïú Î™®Îç∏ Î°úÎî© Î≥ëÎ™© Î∂ÑÏÑù ÌîÑÎ°úÌååÏùºÎü¨
"""
import time
import psutil
import os
import threading
from typing import Dict, List, Any
import logging

class DetailedProfiler:
    """Î™®Îç∏ Î°úÎî©Ïùò Î™®Îì† Îã®Í≥ÑÎ•º ÏÉÅÏÑ∏Ìûà ÌîÑÎ°úÌååÏùºÎßÅ"""
    
    def __init__(self):
        self.logger = logging.getLogger("Profiler")
        self.logger.setLevel(logging.INFO)
        self.start_time = None
        self.checkpoints = []
        self.memory_snapshots = []
        self.io_operations = []
        
    def start_profiling(self, operation_name: str):
        """ÌîÑÎ°úÌååÏùºÎßÅ ÏãúÏûë"""
        self.start_time = time.time()
        self.checkpoints = []
        self.memory_snapshots = []
        self.io_operations = []
        
        self.checkpoint(f"üöÄ {operation_name} ÏãúÏûë")
        self.memory_snapshot("ÏãúÏûë")
        
    def checkpoint(self, description: str):
        """Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ Í∏∞Î°ù"""
        if self.start_time is None:
            return
            
        current_time = time.time()
        elapsed = current_time - self.start_time
        
        if self.checkpoints:
            delta = current_time - self.checkpoints[-1]['timestamp']
            self.logger.info(f"‚è±Ô∏è  [{elapsed:6.1f}s] (+{delta:5.1f}s) {description}")
        else:
            self.logger.info(f"‚è±Ô∏è  [{elapsed:6.1f}s] {description}")
        
        self.checkpoints.append({
            'time': elapsed,
            'timestamp': current_time,
            'description': description
        })
    
    def memory_snapshot(self, stage: str):
        """Î©îÎ™®Î¶¨ Ïä§ÎÉÖÏÉ∑"""
        try:
            process = psutil.Process()
            memory_info = process.memory_info()
            system_memory = psutil.virtual_memory()
            
            snapshot = {
                'stage': stage,
                'process_memory_mb': memory_info.rss / (1024 * 1024),
                'system_memory_percent': system_memory.percent,
                'available_memory_gb': system_memory.available / (1024**3)
            }
            
            self.memory_snapshots.append(snapshot)
            self.logger.info(f"üíæ [{stage}] ÌîÑÎ°úÏÑ∏Ïä§: {snapshot['process_memory_mb']:.1f}MB, "
                           f"ÏãúÏä§ÌÖú: {snapshot['system_memory_percent']:.1f}%, "
                           f"ÏÇ¨Ïö©Í∞ÄÎä•: {snapshot['available_memory_gb']:.1f}GB")
        except Exception as e:
            self.logger.warning(f"Î©îÎ™®Î¶¨ Ïä§ÎÉÖÏÉ∑ Ïã§Ìå®: {e}")
    
    def io_operation(self, operation: str, file_path: str = "", size_mb: float = 0):
        """I/O ÏûëÏóÖ Í∏∞Î°ù"""
        current_time = time.time()
        elapsed = current_time - self.start_time if self.start_time else 0
        
        io_record = {
            'time': elapsed,
            'operation': operation,
            'file_path': file_path,
            'size_mb': size_mb
        }
        
        self.io_operations.append(io_record)
        
        if size_mb > 0:
            self.logger.info(f"üìÅ [{elapsed:6.1f}s] {operation}: {file_path} ({size_mb:.1f}MB)")
        else:
            self.logger.info(f"üìÅ [{elapsed:6.1f}s] {operation}: {file_path}")
    
    def profile_file_operation(self, operation_name: str, file_path: str):
        """ÌååÏùº ÏûëÏóÖ ÌîÑÎ°úÌååÏùºÎßÅ Îç∞ÏΩîÎ†àÏù¥ÌÑ∞"""
        def decorator(func):
            def wrapper(*args, **kwargs):
                try:
                    file_size = os.path.getsize(file_path) / (1024 * 1024) if os.path.exists(file_path) else 0
                    self.io_operation(f"{operation_name} ÏãúÏûë", file_path, file_size)
                    
                    start_time = time.time()
                    result = func(*args, **kwargs)
                    end_time = time.time()
                    
                    self.io_operation(f"{operation_name} ÏôÑÎ£å", file_path)
                    self.checkpoint(f"{operation_name} ÏôÑÎ£å ({end_time - start_time:.1f}Ï¥à)")
                    
                    return result
                except Exception as e:
                    self.checkpoint(f"{operation_name} Ïã§Ìå®: {e}")
                    raise
            return wrapper
        return decorator
    
    def profile_transformers_loading(self):
        """transformers Î°úÎî© Í≥ºÏ†ïÏùÑ ÏÉÅÏÑ∏Ìûà ÌîÑÎ°úÌååÏùºÎßÅ"""
        
        # transformers ÎÇ¥Î∂Ä Ìï®ÏàòÎì§ÏùÑ Ìå®ÏπòÌïòÏó¨ Î°úÍπÖ Ï∂îÍ∞Ä
        try:
            import transformers
            
            # ÏõêÎ≥∏ Ìï®ÏàòÎì§ Ï†ÄÏû•
            original_from_pretrained = transformers.PreTrainedModel.from_pretrained
            original_load_state_dict = transformers.modeling_utils.load_state_dict
            
            def profiled_from_pretrained(cls, *args, **kwargs):
                self.checkpoint("ü§ñ transformers.from_pretrained ÏãúÏûë")
                self.memory_snapshot("from_pretrained ÏãúÏûë")
                
                try:
                    result = original_from_pretrained(*args, **kwargs)
                    self.checkpoint("‚úÖ transformers.from_pretrained ÏôÑÎ£å")
                    self.memory_snapshot("from_pretrained ÏôÑÎ£å")
                    return result
                except Exception as e:
                    self.checkpoint(f"‚ùå transformers.from_pretrained Ïã§Ìå®: {e}")
                    raise
            
            def profiled_load_state_dict(checkpoint_file, *args, **kwargs):
                if isinstance(checkpoint_file, str):
                    file_size = os.path.getsize(checkpoint_file) / (1024 * 1024) if os.path.exists(checkpoint_file) else 0
                    self.io_operation("Í∞ÄÏ§ëÏπò ÌååÏùº Î°úÎî©", checkpoint_file, file_size)
                
                self.checkpoint("üì• load_state_dict ÏãúÏûë")
                start_time = time.time()
                
                try:
                    result = original_load_state_dict(checkpoint_file, *args, **kwargs)
                    load_time = time.time() - start_time
                    self.checkpoint(f"‚úÖ load_state_dict ÏôÑÎ£å ({load_time:.1f}Ï¥à)")
                    return result
                except Exception as e:
                    self.checkpoint(f"‚ùå load_state_dict Ïã§Ìå®: {e}")
                    raise
            
            # Ìå®Ïπò Ï†ÅÏö©
            transformers.PreTrainedModel.from_pretrained = classmethod(profiled_from_pretrained)
            transformers.modeling_utils.load_state_dict = profiled_load_state_dict
            
            self.logger.info("üîß transformers ÌîÑÎ°úÌååÏùºÎßÅ Ìå®Ïπò Ï†ÅÏö© ÏôÑÎ£å")
            
        except Exception as e:
            self.logger.warning(f"transformers Ìå®Ïπò Ïã§Ìå®: {e}")
    
    def profile_safetensors_loading(self):
        """safetensors Î°úÎî© ÌîÑÎ°úÌååÏùºÎßÅ"""
        try:
            from safetensors import safe_open
            
            original_safe_open = safe_open
            
            def profiled_safe_open(filename, *args, **kwargs):
                file_size = os.path.getsize(filename) / (1024 * 1024) if os.path.exists(filename) else 0
                self.io_operation("safetensors ÌååÏùº Ïó¥Í∏∞", filename, file_size)
                self.checkpoint("üîê safetensors ÌååÏùº Ïó¥Í∏∞ ÏãúÏûë")
                
                start_time = time.time()
                try:
                    result = original_safe_open(filename, *args, **kwargs)
                    load_time = time.time() - start_time
                    self.checkpoint(f"‚úÖ safetensors ÌååÏùº Ïó¥Í∏∞ ÏôÑÎ£å ({load_time:.1f}Ï¥à)")
                    return result
                except Exception as e:
                    self.checkpoint(f"‚ùå safetensors ÌååÏùº Ïó¥Í∏∞ Ïã§Ìå®: {e}")
                    raise
            
            # Ìå®Ïπò Ï†ÅÏö© (Î™®Îìà Î†àÎ≤®ÏóêÏÑú)
            import safetensors
            safetensors.safe_open = profiled_safe_open
            
            self.logger.info("üîß safetensors ÌîÑÎ°úÌååÏùºÎßÅ Ìå®Ïπò Ï†ÅÏö© ÏôÑÎ£å")
            
        except Exception as e:
            self.logger.warning(f"safetensors Ìå®Ïπò Ïã§Ìå®: {e}")
    
    def analyze_bottlenecks(self) -> Dict[str, Any]:
        """Î≥ëÎ™© ÏßÄÏ†ê Î∂ÑÏÑù"""
        if not self.checkpoints:
            return {"error": "ÌîÑÎ°úÌååÏùºÎßÅ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå"}
        
        # Îã®Í≥ÑÎ≥Ñ ÏãúÍ∞Ñ Î∂ÑÏÑù
        step_times = []
        for i in range(1, len(self.checkpoints)):
            prev_time = self.checkpoints[i-1]['time']
            curr_time = self.checkpoints[i]['time']
            delta = curr_time - prev_time
            
            step_times.append({
                'step': self.checkpoints[i]['description'],
                'duration': delta,
                'cumulative': curr_time
            })
        
        # Î≥ëÎ™© ÏßÄÏ†ê ÏãùÎ≥Ñ (5Ï¥à Ïù¥ÏÉÅ Í±∏Î¶¨Îäî Îã®Í≥ÑÎì§)
        bottlenecks = [step for step in step_times if step['duration'] > 5.0]
        bottlenecks.sort(key=lambda x: x['duration'], reverse=True)
        
        # Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Î∂ÑÏÑù
        memory_growth = []
        if len(self.memory_snapshots) > 1:
            for i in range(1, len(self.memory_snapshots)):
                prev_mem = self.memory_snapshots[i-1]['process_memory_mb']
                curr_mem = self.memory_snapshots[i]['process_memory_mb']
                growth = curr_mem - prev_mem
                
                memory_growth.append({
                    'stage': self.memory_snapshots[i]['stage'],
                    'growth_mb': growth,
                    'total_mb': curr_mem
                })
        
        analysis = {
            'total_time': self.checkpoints[-1]['time'] if self.checkpoints else 0,
            'step_count': len(self.checkpoints),
            'bottlenecks': bottlenecks,
            'memory_growth': memory_growth,
            'io_operations': len(self.io_operations)
        }
        
        return analysis
    
    def print_detailed_report(self):
        """ÏÉÅÏÑ∏Ìïú Î∂ÑÏÑù Î¶¨Ìè¨Ìä∏ Ï∂úÎ†•"""
        analysis = self.analyze_bottlenecks()
        
        print("\n" + "="*80)
        print("üîç ÏÉÅÏÑ∏Ìïú Î™®Îç∏ Î°úÎî© Î≥ëÎ™© Î∂ÑÏÑù Î¶¨Ìè¨Ìä∏")
        print("="*80)
        
        print(f"üìä Ï†ÑÏ≤¥ ÏöîÏïΩ:")
        print(f"   Ï¥ù ÏÜåÏöîÏãúÍ∞Ñ: {analysis['total_time']:.1f}Ï¥à")
        print(f"   Ï¥ù Îã®Í≥Ñ Ïàò: {analysis['step_count']}")
        print(f"   I/O ÏûëÏóÖ Ïàò: {analysis['io_operations']}")
        
        print(f"\nüö® Ï£ºÏöî Î≥ëÎ™© ÏßÄÏ†ê (5Ï¥à Ïù¥ÏÉÅ):")
        if analysis['bottlenecks']:
            for i, bottleneck in enumerate(analysis['bottlenecks'][:5], 1):
                print(f"   {i}. {bottleneck['step']}")
                print(f"      ‚è±Ô∏è  ÏÜåÏöîÏãúÍ∞Ñ: {bottleneck['duration']:.1f}Ï¥à")
                print(f"      üìç ÎàÑÏ†ÅÏãúÍ∞Ñ: {bottleneck['cumulative']:.1f}Ï¥à")
                print()
        else:
            print("   ‚úÖ 5Ï¥à Ïù¥ÏÉÅ Í±∏Î¶¨Îäî Îã®Í≥Ñ ÏóÜÏùå")
        
        print(f"üíæ Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Î≥ÄÌôî:")
        if analysis['memory_growth']:
            for growth in analysis['memory_growth']:
                if growth['growth_mb'] > 10:  # 10MB Ïù¥ÏÉÅ Ï¶ùÍ∞ÄÌïú Í≤ΩÏö∞Îßå
                    print(f"   üìà {growth['stage']}: +{growth['growth_mb']:.1f}MB "
                          f"(Ï¥ù {growth['total_mb']:.1f}MB)")
        
        print(f"\nüí° ÏµúÏ†ÅÌôî Ï†úÏïà:")
        
        # Î≥ëÎ™© Í∏∞Î∞ò Ï†úÏïà
        if analysis['bottlenecks']:
            max_bottleneck = analysis['bottlenecks'][0]
            if "Î™®Îç∏ ÏÉùÏÑ±" in max_bottleneck['step']:
                print("   üéØ Î™®Îç∏ ÏÉùÏÑ±Ïù¥ Í∞ÄÏû• ÌÅ∞ Î≥ëÎ™©ÏûÖÎãàÎã§")
                print("   üíä Ìï¥Í≤∞Ï±Ö: from_config ÎåÄÏã† ÏßÅÏ†ë ÌÖêÏÑú Î°úÎî© ÏÇ¨Ïö©")
            elif "ÌÖêÏÑú Ìï†Îãπ" in max_bottleneck['step']:
                print("   üéØ ÌÖêÏÑú Ìï†ÎãπÏù¥ Í∞ÄÏû• ÌÅ∞ Î≥ëÎ™©ÏûÖÎãàÎã§")
                print("   üíä Ìï¥Í≤∞Ï±Ö: Î≥ëÎ†¨ ÌÖêÏÑú Î°úÎî© ÎòêÎäî Î©îÎ™®Î¶¨ Îß§Ìïë ÏÇ¨Ïö©")
            elif "from_pretrained" in max_bottleneck['step']:
                print("   üéØ transformers from_pretrainedÍ∞Ä Í∞ÄÏû• ÌÅ∞ Î≥ëÎ™©ÏûÖÎãàÎã§")
                print("   üíä Ìï¥Í≤∞Ï±Ö: ÌôòÍ≤Ω Î≥ÄÏàò ÏµúÏ†ÅÌôî Î∞è Í≤ÄÏ¶ù Ïö∞Ìöå")
        
        print("="*80)

# Ï†ÑÏó≠ ÌîÑÎ°úÌååÏùºÎü¨
profiler = DetailedProfiler()